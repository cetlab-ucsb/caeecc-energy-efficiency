---
title: "regressions"
author: "Public Sector UWG Team"
date: "4/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/Documents/Github/caeecc-energy-efficiency/for github/data')
```

```{r, load packages}
library(readr)
library(data.table)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(psych)
library(car)
library(fitdistrplus)
```

```{r, EE Programs at the County Level}
#read in data for County EE programs 
counties<-read.csv("counties_2.csv")
View(counties)
```

```{r, county—check}
#scatter plot matrix to check for correlation between county specific varaibles and investment/energy savings
plot.counties <- data.frame(counties$County, counties$Population, counties$Budget, counties$TotalFirstYearGrosskWh, counties$TotalRevenue, counties$Mean.Income, counties$IRR, counties$dac_proportion, counties$ces_score_median, counties$ces_percentile_median, counties$X..OBF.Budget, counties$X..Resource.Budget) #subset out these variables
colnames(plot.counties)<-c("County", "Population", "Budget", "TotalFirstYearGrosskWh", "Total Revenue", "Mean Income", "IRR", "dac_proportion", "ces_score_median", "ces_percentile_median", "X..OBF.Budget", "X..Resource.Budget" ) #change column names back to original
pairs.panels(plot.counties, density = TRUE, cor=TRUE, lm=TRUE) #scatterplot
```


```{r, county}
#log-transform the population to account for the skew
counties$ln_Population <- log(counties$Population)
#visualize the normal distribution
hist(counties$ln_Population)
```


```{r}
#log-transform the population to account for the skew
counties$ln_totalrevenue <- log(counties$TotalRevenue)
#visualize the normal distribution
hist(counties$ln_totalrevenue)
```


```{r}
#split into groups based on quantiles and population
quantile(counties$Population)

#split into groups based on arbitrary numbers for population 
counties_g1 <- subset(counties, Population <= 47646.75)
counties_g2 <- subset(counties, Population > 47646.75 & Population <= 184632.00)
counties_g3 <- subset(counties, Population > 184632.00 & Population <= 692750.75)
counties_g4 <- subset(counties, Population > 692750.75)
```

```{r, county grouped w/ population}
#check the distribution of the predictor variable of interest (Budget)
hist(counties_g1$Budget)
hist(counties_g2$Budget)
hist(counties_g3$Budget)
hist(counties_g4$Budget)
```

```{r, county grouped w/ population}
#check the distribution of the predictor variable of interest (Energy Savings)
hist(counties_g1$TotalFirstYearGrosskWh)
hist(counties_g2$TotalFirstYearGrosskWh)
hist(counties_g3$TotalFirstYearGrosskWh)
hist(counties_g4$TotalFirstYearGrosskWh)
```

```{r, county quantiles w/ ln(pop)}
#split into groups based on quantiles of ln_pop
quantile(counties$ln_Population)

#group data by ln_population
counties_lnq1 <- subset(counties, ln_Population < 10.768725)
counties_lnq2 <- subset(counties, ln_Population >= 10.768725 & ln_Population < 12.125893)
counties_lnq3 <- subset(counties, ln_Population >= 12.125893 & ln_Population < 13.439743)
counties_lnq4 <- subset(counties, ln_Population > 13.439743)
```

```{r, county quantiles w/ ln(pop)}
#check the distribution of the predictor variable of interest (Budget)
hist(counties_lnq1$Budget)
hist(counties_lnq2$Budget)
hist(counties_lnq3$Budget)
hist(counties_lnq4$Budget)
```

```{r, county quantiles w/ ln(pop)}
#check the distribution of the predictor variable of interest (Energy Savings)
hist(counties_lnq1$TotalFirstYearGrosskWh)
hist(counties_lnq2$TotalFirstYearGrosskWh)
hist(counties_lnq3$TotalFirstYearGrosskWh)
hist(counties_lnq4$TotalFirstYearGrosskWh)
```

```{r, county grouped w/ population}
#round y because GLM works best with integers using groups based on arbitrary numbers for population  
counties_g1$rounded_budget <- round(counties_g1$Budget, 0)
counties_g2$rounded_budget <- round(counties_g2$Budget, 0)
counties_g3$rounded_budget <- round(counties_g3$Budget, 0)
counties_g4$rounded_budget <- round(counties_g4$Budget, 0)

counties_g1$rounded_kWh <- round(counties_g1$TotalFirstYearGrosskWh, 0)
counties_g2$rounded_kWh <- round(counties_g2$TotalFirstYearGrosskWh, 0)
counties_g3$rounded_kWh <- round(counties_g3$TotalFirstYearGrosskWh, 0)
counties_g4$rounded_kWh <- round(counties_g4$TotalFirstYearGrosskWh, 0)
```

```{r, county grouped w/ population}
#check which distribution would be best for the budget of the SMALLEST population group
library(fitdistrplus)
counties1_pois <- fitdist(counties_g1$rounded_budget, "pois") #CHECK
counties1_nbin <- fitdist(counties_g1$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(counties1_pois, counties1_nbin))
qqcomp(list(counties1_pois, counties1_nbin))

summary(counties1_pois)
summary(counties1_nbin)
```

```{r, county grouped w/ population}
#check which distribution would be best for the budget of the second SMALLEST population group
library(fitdistrplus)
counties2_pois <- fitdist(counties_g2$rounded_budget, "pois") #CHECK
counties2_nbin <- fitdist(counties_g2$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(counties2_pois, counties2_nbin))
qqcomp(list(counties2_pois, counties2_nbin))

summary(counties2_pois)
summary(counties2_nbin)
```

```{r, county grouped w/ population}
#check which distribution would be best for the budget of the second LARGEST population group
library(fitdistrplus)
counties3_pois <- fitdist(counties_g3$rounded_budget, "pois") #CHECK
counties3_nbin <- fitdist(counties_g3$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(counties3_pois, counties3_nbin))
qqcomp(list(counties3_pois, counties3_nbin))

summary(counties3_pois)
summary(counties3_nbin)
```

```{r, county grouped w/ population}
#check which distribution would be best for the budget of the LARGEST population group
library(fitdistrplus)
counties4_pois <- fitdist(counties_g4$rounded_budget, "pois") #CHECK
counties4_nbin <- fitdist(counties_g4$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(counties4_pois, counties4_nbin))
qqcomp(list(counties4_pois, counties4_nbin))

summary(counties4_pois)
summary(counties4_nbin)
```


```{r, county quantiles w/ ln(pop)}
#round y because GLM works best with integers using quantiles split by log of population
counties_lnq1$rounded_budget <- round(counties_lnq1$Budget, 0)
counties_lnq2$rounded_budget <- round(counties_lnq2$Budget, 0)
counties_lnq3$rounded_budget <- round(counties_lnq3$Budget, 0)
counties_lnq4$rounded_budget <- round(counties_lnq4$Budget, 0)

counties_lnq1$rounded_kWh <- round(counties_lnq1$TotalFirstYearGrosskWh, 0)
counties_lnq2$rounded_kWh <- round(counties_lnq2$TotalFirstYearGrosskWh, 0)
counties_lnq3$rounded_kWh <- round(counties_lnq3$TotalFirstYearGrosskWh, 0)
counties_lnq4$rounded_kWh <- round(counties_lnq4$TotalFirstYearGrosskWh, 0)
```

```{r, county quantiles w/ ln(pop)—check}
#check which distribution would be best for the budget of the SMALLEST population group
library(fitdistrplus)
county1_pois <- fitdist(counties_lnq1$rounded_budget, "pois") #CHECK
county1_nbin <- fitdist(counties_lnq1$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(county1_pois, county1_nbin))
qqcomp(list(county1_pois, county1_nbin))

summary(county1_pois)
summary(county1_nbin)
```
```{r, county quantiles w/ ln(pop)}
#check which distribution would be best for the budget of the second SMALLEST population group
library(fitdistrplus)
county2_pois <- fitdist(counties_lnq2$rounded_budget, "pois") #CHECK
county2_nbin <- fitdist(counties_lnq2$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(county2_pois, county2_nbin))
qqcomp(list(county2_pois, county2_nbin))

summary(county2_pois)
summary(county2_nbin)
```

```{r, county quantiles w/ ln(pop)}
#check which distribution would be best for the budget of the second LARGEST population group
library(fitdistrplus)
county3_pois <- fitdist(counties_lnq3$rounded_budget, "pois") #CHECK
county3_nbin <- fitdist(counties_lnq3$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(county3_pois, county3_nbin))
qqcomp(list(county3_pois, county3_nbin))

summary(county3_pois)
summary(county3_nbin)
```

```{r, county quantiles w/ ln(pop)}
#check which distribution would be best for the budget of the LARGEST population group
library(fitdistrplus)
county4_pois <- fitdist(counties_lnq4$rounded_budget, "pois") #CHECK
county4_nbin <- fitdist(counties_lnq4$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(county4_pois, county4_nbin))
qqcomp(list(county4_pois, county4_nbin))

summary(county4_pois)
summary(county4_nbin)
```
```{r, county ungrouped}
#check the distributions
hist(counties$Budget)
hist(counties$TotalFirstYearGrosskWh)

#round the budget and kWh
counties$rounded_budget <- round(counties$Budget, 0)
counties$rounded_kWh <- round(counties$TotalFirstYearGrosskWh, 0)
```

```{r, county ungrouped}
#poisson regression for budget just using county data, not split into quantiles/groups yet
counties1.glm <- glm(rounded_budget ~ TotalRevenue, data = counties, family = "poisson")
counties2.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties, family = "poisson")
counties3.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties, family = "poisson")
counties4.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties, family = "poisson")
counties5.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties, family = "poisson")
counties6.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income + Population, data = counties, family = "poisson")
counties7.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income, data = counties, family = "poisson")
counties8.glm <- glm(rounded_budget ~ TotalRevenue + IRR + Mean.Income, data = counties, family = "poisson")
counties9.glm <- glm(rounded_budget ~ IRR + Mean.Income + Population, data = counties, family = "poisson")

summary(counties1.glm) #p-value should be < 0.05 to be significant 
summary(counties2.glm)
summary(counties3.glm)
summary(counties4.glm)
summary(counties5.glm)
summary(counties6.glm)
summary(counties7.glm)
summary(counties8.glm)
summary(counties9.glm)
```

```{r, county ungrouped}
#poisson regression for kWh just using county data, not split into quantiles/groups yet
counties10.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties, family = "poisson")
counties12.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties, family = "poisson")
counties13.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties, family = "poisson")
counties14.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties, family = "poisson")
counties15.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties, family = "poisson")
counties16.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income + Population, data = counties, family = "poisson")
counties17.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income, data = counties, family = "poisson")
counties18.glm <- glm(rounded_kWh ~ TotalRevenue + IRR + Mean.Income, data = counties, family = "poisson")
counties19.glm <- glm(rounded_kWh ~ IRR + Mean.Income + Population, data = counties, family = "poisson")

summary(counties10.glm) #p-value should be < 0.05 to be significant 
summary(counties12.glm)
summary(counties13.glm)
summary(counties14.glm)
summary(counties15.glm)
summary(counties16.glm)
summary(counties17.glm)
summary(counties18.glm)
summary(counties19.glm)
```

```{r}
result <- AIC(counties1.glm, counties2.glm, counties3.glm, counties4.glm, counties5.glm, counties6.glm, counties7.glm,  counties8.glm, counties9.glm)
result1<-BIC(counties1.glm, counties2.glm, counties3.glm, counties4.glm, counties5.glm, counties6.glm, counties7.glm,  counties8.glm, counties9.glm)
models <- list(counties1.glm, counties2.glm, counties3.glm, counties4.glm, counties5.glm, counties6.glm, counties7.glm,  counties8.glm, counties9.glm)
result$BIC <- sapply(models, BIC)
model_summary <- lapply(models, summary)
model_summary
for(i in 1:length(models)){
  result$rsq[i] <- model_summary[[i]]$r.squared 
  result$adj_rsq[i] <- model_summary[[i]]$adj.r.squared 
} 

library(knitr)
kable(result, digits = 2, align = "c")
```

```{r, county grouped w/ population}
#poisson budget regression for q1 using just population
counties1a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_g1, family = "poisson")
counties1b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_g1, family = "poisson")
counties1c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_g1, family = "poisson")
counties1d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g1, family = "poisson")
counties1f.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g1, family = "poisson")
counties1g.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1h.glm <- glm(rounded_budget ~ TotalRevenue + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1i.glm <- glm(rounded_budget ~ IRR + Mean.Income + Population, data = counties_g1, family = "poisson")

summary(counties1a.glm) #p-value should be < 0.05 to be significant 
summary(counties1b.glm)
summary(counties1c.glm)
summary(counties1d.glm)
summary(counties1e.glm)
summary(counties1f.glm)
summary(counties1g.glm)
summary(counties1h.glm)
summary(counties1i.glm)
```

```{r, county grouped w/ population}
#poisson energy savings regression for q1 with quantiles based on just population
counties1j.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_g1, family = "poisson")
counties1k.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_g1, family = "poisson")
counties1l.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_g1, family = "poisson")
counties1m.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1n.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g1, family = "poisson")
counties1o.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g1, family = "poisson")
counties1p.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1q.glm <- glm(rounded_kWh ~ TotalRevenue + IRR + Mean.Income, data = counties_g1, family = "poisson")
counties1r.glm <- glm(rounded_kWh ~ IRR + Mean.Income + Population, data = counties_g1, family = "poisson")

summary(counties1j.glm) #p-value should be < 0.05 to be significant 
summary(counties1k.glm)
summary(counties1l.glm)
summary(counties1m.glm)
summary(counties1n.glm)
summary(counties1o.glm)
summary(counties1p.glm)
summary(counties1q.glm)
summary(counties1r.glm)
```

```{r}
#poisson budget regression for q2 using just population
counties2a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_g2, family = "poisson")
counties2b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_g2, family = "poisson")
counties2c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_g2, family = "poisson")
counties2d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g2, family = "poisson")
counties2f.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g2, family = "poisson")
counties2g.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2h.glm <- glm(rounded_budget ~ TotalRevenue + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2i.glm <- glm(rounded_budget ~ IRR + Mean.Income + Population, data = counties_g2, family = "poisson")

summary(counties2a.glm) #p-value should be < 0.05 to be significant 
summary(counties2b.glm)
summary(counties2c.glm)
summary(counties2d.glm)
summary(counties2e.glm)
summary(counties2f.glm)
summary(counties2g.glm)
summary(counties2h.glm)
summary(counties2i.glm)
```

```{r}
#poisson energy savings regression for q2 with quantiles based on just population
counties2j.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_g2, family = "poisson")
counties2k.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_g2, family = "poisson")
counties2l.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_g2, family = "poisson")
counties2m.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2n.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g2, family = "poisson")
counties2o.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g2, family = "poisson")
counties2p.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2q.glm <- glm(rounded_kWh ~ TotalRevenue + IRR + Mean.Income, data = counties_g2, family = "poisson")
counties2r.glm <- glm(rounded_kWh ~ IRR + Mean.Income + Population, data = counties_g2, family = "poisson")

summary(counties2j.glm) #p-value should be < 0.05 to be significant 
summary(counties2k.glm)
summary(counties2l.glm)
summary(counties2m.glm)
summary(counties2n.glm)
summary(counties2o.glm)
summary(counties2p.glm)
summary(counties2q.glm)
summary(counties2r.glm)
```

```{r}
#poisson budget regression for q3 using just population
counties3a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_g3, family = "poisson")
counties3b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_g3, family = "poisson")
counties3c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_g3, family = "poisson")
counties3d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g3, family = "poisson")
counties3f.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g3, family = "poisson")
counties3g.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3h.glm <- glm(rounded_budget ~ TotalRevenue + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3i.glm <- glm(rounded_budget ~ IRR + Mean.Income + Population, data = counties_g3, family = "poisson")

summary(counties3a.glm) #p-value should be < 0.05 to be significant 
summary(counties3b.glm)
summary(counties3c.glm)
summary(counties3d.glm)
summary(counties3e.glm)
summary(counties3f.glm)
summary(counties3g.glm)
summary(counties3h.glm)
summary(counties3i.glm)
```

```{r}
#poisson energy savings regression for q3 with quantiles based on just population
counties3j.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_g3, family = "poisson")
counties3k.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_g3, family = "poisson")
counties3l.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_g3, family = "poisson")
counties3m.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3n.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g3, family = "poisson")
counties3o.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g3, family = "poisson")
counties3p.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3q.glm <- glm(rounded_kWh ~ TotalRevenue + IRR + Mean.Income, data = counties_g3, family = "poisson")
counties3ir.glm <- glm(rounded_kWh ~ IRR + Mean.Income + Population, data = counties_g3, family = "poisson")

summary(counties3j.glm) #p-value should be < 0.05 to be significant 
summary(counties3k.glm)
summary(counties3l.glm)
summary(counties3m.glm)
summary(counties3n.glm)
summary(counties3o.glm)
summary(counties3p.glm)
summary(counties3q.glm)
summary(counties3r.glm)
```

```{r}
#poisson budget regression for q3 using just population
counties4a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_g4, family = "poisson")
counties4b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_g4, family = "poisson")
counties4c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_g4, family = "poisson")
counties4d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g4, family = "poisson")
counties4f.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g3, family = "poisson")
counties4g.glm <- glm(rounded_budget ~ ces_score_median + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4h.glm <- glm(rounded_budget ~ TotalRevenue + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4i.glm <- glm(rounded_budget ~ IRR + Mean.Income + Population, data = counties_g4, family = "poisson")

summary(counties4a.glm) #p-value should be < 0.05 to be significant 
summary(counties4b.glm)
summary(counties4c.glm)
summary(counties4d.glm)
summary(counties4e.glm)
summary(counties4f.glm)
summary(counties4g.glm)
summary(counties4h.glm)
summary(counties4i.glm)
```

```{r}
#poisson energy savings regression for q3 with quantiles based on just population
counties4j.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_g4, family = "poisson")
counties4k.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_g4, family = "poisson")
counties4l.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_g4, family = "poisson")
counties4m.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4n.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_g4, family = "poisson")
counties4o.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income + Population, data = counties_g4, family = "poisson")
counties4p.glm <- glm(rounded_kWh ~ ces_score_median + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4q.glm <- glm(rounded_kWh ~ TotalRevenue + IRR + Mean.Income, data = counties_g4, family = "poisson")
counties4ir.glm <- glm(rounded_kWh ~ IRR + Mean.Income + Population, data = counties_g4, family = "poisson")

summary(counties4j.glm) #p-value should be < 0.05 to be significant 
summary(counties4k.glm)
summary(counties4l.glm)
summary(counties4m.glm)
summary(counties4n.glm)
summary(counties4o.glm)
summary(counties4p.glm)
summary(counties4q.glm)
summary(counties4r.glm)
```

````{r, county}
#poisson budget regression for q1
counties_1a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_lnq1, family = "poisson")
counties_1b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq1, family = "poisson")
counties_1c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq1, family = "poisson")
counties_1d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq1, family = "poisson")
counties_1e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq1, family = "poisson")

summary(counties_1a.glm) #p-value should be < 0.05 to be significant 
summary(counties_1b.glm)
summary(counties_1c.glm)
summary(counties_1d.glm)
summary(counties_1e.glm)
```
The code above shows 5 different combinations of variables. For each poisson regression, every variable is significant (weirdly with the same p-value of <2e-16 which is R's way of indicating a very small number) however there are small coefficients. IRR is most significant in this case.

```{r}
result <- AIC(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm)
result1<-BIC(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm)
models <- list(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm)
result$BIC <- sapply(models, BIC)
model_summary <- lapply(models, summary)
model_summary
for(i in 1:length(models)){
  result$rsq[i] <- model_summary[[i]]$r.squared 
  result$adj_rsq[i] <- model_summary[[i]]$adj.r.squared 
} 

library(knitr)
kable(result, digits = 2, align = "c")
```

```{r}
#a way to try an verify if this model is actually a good fit for the data 
with(counties_1a.glm, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=FALSE)))
with(counties_1b.glm, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
with(counties_1c.glm, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=FALSE)))
with(counties_1d.glm, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=FALSE)))
with(counties_1e.glm, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=FALSE)))
```


````{r, county}
#poisson energy savings regression for q1
counties_1f.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_lnq1, family = "poisson")
counties_1g.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq1, family = "poisson")
counties_1h.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq1, family = "poisson")
counties_1i.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq1, family = "poisson")
counties_1j.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq1, family = "poisson")

summary(counties_1f.glm) #p-value should be < 0.05 to be significant 
summary(counties_1g.glm)
summary(counties_1h.glm)
summary(counties_1i.glm)
summary(counties_1j.glm)
```

```{r, county}
#validate your budget model for q1
anova(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm) #the smaller the value the better
BIC(counties_1a.glm, counties_1b.glm, counties_1c.glm, counties_1d.glm, counties_1e.glm) #the smaller the value the better
```
The p-values from the anova gave <2.2e-16 error, but counties_1e.glm is shown to be the best regression based on the AIC and BIC values.

```{r, county}
#validate your energy savings modelfor q1
anova(counties_1f.glm, counties_1g.glm, counties_1h.glm, counties_1i.glm, counties_1j.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_1f.glm, counties_1g.glm, counties_1h.glm, counties_1i.glm, counties_1j.glm) #the smaller the value the better
BIC(counties_1f.glm, counties_1g.glm, counties_1h.glm, counties_1i.glm, counties_1j.glm) #the smaller the value the better
```

```{r}
#poisson budget regression for q2
counties_2a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_lnq2, family = "poisson")
counties_2b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq2, family = "poisson")
counties_2c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq2, family = "poisson")
counties_2d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq2, family = "poisson")
counties_2e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq2, family = "poisson")

summary(counties_2a.glm) #p-value should be < 0.05 to be significant 
summary(counties_2b.glm)
summary(counties_2c.glm)
summary(counties_2d.glm)
summary(counties_2e.glm)
```

```{r}
#validate your budget model for q2
anova(counties_2a.glm, counties_2b.glm, counties_2c.glm, counties_2d.glm, counties_2e.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_2a.glm, counties_2b.glm, counties_2c.glm, counties_2d.glm, counties_2e.glm) #the smaller the value the better
BIC(counties_2a.glm, counties_2b.glm, counties_2c.glm, counties_2d.glm, counties_2e.glm) #the smaller the value the better
```

```{r}
#poisson energy savings regression for q2
counties_2f.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_lnq2, family = "poisson")
counties_2g.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq2, family = "poisson")
counties_2h.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq2, family = "poisson")
counties_2i.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq2, family = "poisson")
counties_2j.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq2, family = "poisson")

summary(counties_2f.glm) #p-value should be < 0.05 to be significant 
summary(counties_2g.glm)
summary(counties_2h.glm)
summary(counties_2i.glm)
summary(counties_2j.glm)
```

```{r}
#validate your energy savings model for q2
anova(counties_2f.glm, counties_2g.glm, counties_2h.glm, counties_2i.glm, counties_2j.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_2f.glm, counties_2g.glm, counties_2h.glm, counties_2i.glm, counties_2j.glm) #the smaller the value the better
BIC(counties_2f.glm, counties_2g.glm, counties_2h.glm, counties_2i.glm, counties_2j.glm) #the smaller the value the better
```

```{r}
#poisson budget regression for q3
counties_3a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_lnq3, family = "poisson")
counties_3b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq3, family = "poisson")
counties_3c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq3, family = "poisson")
counties_3d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq3, family = "poisson")
counties_3e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq3, family = "poisson")

summary(counties_3a.glm) #p-value should be < 0.05 to be significant 
summary(counties_3b.glm)
summary(counties_3c.glm)
summary(counties_3d.glm)
summary(counties_3e.glm)
```

```{r}
#validate your budget model for q3
anova(counties_3a.glm, counties_3b.glm, counties_3c.glm, counties_3d.glm, counties_3e.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_3a.glm, counties_3b.glm, counties_3c.glm, counties_3d.glm, counties_3e.glm) #the smaller the value the better
BIC(counties_3a.glm, counties_3b.glm, counties_3c.glm, counties_3d.glm, counties_3e.glm) #the smaller the value the better
```

```{r}
#poisson energy savings regression for q3
counties_3f.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_lnq3, family = "poisson")
counties_3g.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq3, family = "poisson")
counties_3h.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq3, family = "poisson")
counties_3i.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq3, family = "poisson")
counties_3j.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq3, family = "poisson")

summary(counties_3f.glm) #p-value should be < 0.05 to be significant 
summary(counties_3g.glm)
summary(counties_3h.glm)
summary(counties_3i.glm)
summary(counties_3j.glm)
```

```{r}
#validate your energy savings model for q3
anova(counties_3f.glm, counties_3g.glm, counties_3h.glm, counties_3i.glm, counties_3j.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_3f.glm, counties_3g.glm, counties_3h.glm, counties_3i.glm, counties_3j.glm) #the smaller the value the better
BIC(counties_3f.glm, counties_3g.glm, counties_3h.glm, counties_3i.glm, counties_3j.glm) #the smaller the value the better
```

```{r}
#poisson budget regression for q4
counties_4a.glm <- glm(rounded_budget ~ TotalRevenue, data = counties_lnq4, family = "poisson")
counties_4b.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq4, family = "poisson")
counties_4c.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq4, family = "poisson")
counties_4d.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq4, family = "poisson")
counties_4e.glm <- glm(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq4, family = "poisson")

summary(counties_4a.glm) #p-value should be < 0.05 to be significant 
summary(counties_4b.glm)
summary(counties_4c.glm)
summary(counties_4d.glm)
summary(counties_4e.glm)
```

```{r}
#validate your budget model for q4
anova(counties_4a.glm, counties_4b.glm, counties_4c.glm, counties_4d.glm, counties_4e.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_4a.glm, counties_4b.glm, counties_4c.glm, counties_4d.glm, counties_4e.glm) #the smaller the value the better
BIC(counties_4a.glm, counties_4b.glm, counties_4c.glm, counties_4d.glm, counties_4e.glm) #the smaller the value the better
```

```{r}
#poisson energy savings regression for q4
counties_4f.glm <- glm(rounded_kWh ~ TotalRevenue, data = counties_lnq4, family = "poisson")
counties_4g.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq4, family = "poisson")
counties_4h.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq4, family = "poisson")
counties_4i.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq4, family = "poisson")
counties_4j.glm <- glm(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq4, family = "poisson")

summary(counties_4f.glm) #p-value should be < 0.05 to be significant 
summary(counties_4g.glm)
summary(counties_4h.glm)
summary(counties_4i.glm)
summary(counties_4j.glm)
```

```{r}
#validate your energy savings model for q4
anova(counties_4f.glm, counties_4g.glm, counties_4h.glm, counties_4i.glm, counties_4j.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties_4f.glm, counties_4g.glm, counties_4h.glm, counties_4i.glm, counties_4j.glm) #the smaller the value the better
BIC(counties_4f.glm, counties_4g.glm, counties_4h.glm, counties_4i.glm, counties_4j.glm) #the smaller the value the better
```

```{r}
#negative binomial budget model for all county data
counties1_glm.nb <- glm.nb(Budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties)
counties2_glm.nb <- glm.nb(Budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties)
counties3_glm.nb <- glm.nb(Budget ~ TotalRevenue + ces_score_median + IRR, data = counties)
counties4_glm.nb <- glm.nb(Budget ~ TotalRevenue + ces_score_median, data = counties)
counties5_glm.nb <- glm.nb(Budget ~ TotalRevenue, data = counties)


summary(counties1_glm.nb)#p-value should be < 0.05 to be significant
summary(counties2_glm.nb)
summary(counties3_glm.nb)
summary(counties4_glm.nb)
summary(counties5_glm.nb)
```

```{r}
#validate your budget model for all county data
anova(counties1_glm.nb, counties2_glm.nb, counties3_glm.nb, counties4_glm.nb, counties5_glm.nb, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties1_glm.nb, counties2_glm.nb, counties3_glm.nb, counties4_glm.nb, counties5_glm.nb) #the smaller the value the better
BIC(counties1_glm.nb, counties2_glm.nb, counties3_glm.nb, counties4_glm.nb, counties5_glm.nb) #the smaller the value the better
```


```{r, county—check}
#negative binomial budget model for q1
counties1a_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq1)
counties1b_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq1)
counties1c_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq1)
counties1d_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq1)
counties1e_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue, data = counties_lnq1)


summary(counties1a_glm.nb)#p-value should be < 0.05 to be significant
summary(counties1b_glm.nb)
summary(counties1c_glm.nb)
summary(counties1d_glm.nb)
summary(counties1e_glm.nb)
```

```{r}
#validate your budget model for q1
anova(counties1a_glm.nb, counties1b_glm.nb, counties1c_glm.nb, counties1d_glm.nb, counties1e_glm.nb, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties1a_glm.nb, counties1b_glm.nb, counties1c_glm.nb, counties1d_glm.nb, counties1e_glm.nb) #the smaller the value the better
BIC(counties1a_glm.nb, counties1b_glm.nb, counties1c_glm.nb, counties1d_glm.nb, counties1e_glm.nb) #the smaller the value the better
```


```{r}
#Checking to see if the regression actually fits the data
with(counties1a_glm.nb, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
with(counties1b_glm.nb, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
with(counties1c_glm.nb, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
with(counties1d_glm.nb, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
with(counties1e_glm.nb, cbind(res.deviance = deviance, df = df.residual,
  p = pchisq(deviance, df.residual, lower.tail=TRUE)))
```


```{r, county—check}
#negative binomial energy savings model for q1
counties1f_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq1)
counties1g_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq1)
counties1h_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq1)
counties1i_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq1)
counties1j_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue, data = counties_lnq1)

summary(counties1f_glm.nb)
summary(counties1g_glm.nb)
summary(counties1h_glm.nb)
summary(counties1i_glm.nb)
summary(counties1j_glm.nb)
```

```{r}
#validate your energy savings model for q1
anova(counties1f_glm.nb, counties1g_glm.nb, counties1h_glm.nb, counties1i_glm.nb, counties1j_glm.nb, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties1f_glm.nb, counties1g_glm.nb, counties1h_glm.nb, counties1i_glm.nb, counties1j_glm.nb) #the smaller the value the better
BIC(counties1f_glm.nb, counties1g_glm.nb, counties1h_glm.nb, counties1i_glm.nb, counties1j_glm.nb) #the smaller the value the better
```


```{r}
#negative binomial budget model for q2
counties2a_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq2)
counties2b_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq2)
counties2c_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq2)
counties2d_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq2)
counties2e_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue, data = counties_lnq2)


summary(counties2a_glm.nb)#p-value should be < 0.05 to be significant
summary(counties2b_glm.nb)
summary(counties2c_glm.nb)
summary(counties2d_glm.nb)
summary(counties2e_glm.nb)
```

```{r}
#validate your budget model for q2
anova(counties2a_glm.nb, counties2b_glm.nb, counties2c_glm.nb, counties2d_glm.nb, counties2e_glm.nb, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties2a_glm.nb, counties2b_glm.nb, counties2c_glm.nb, counties2d_glm.nb, counties2e_glm.nb) #the smaller the value the better
BIC(counties2a_glm.nb, counties2b_glm.nb, counties2c_glm.nb, counties2d_glm.nb, counties2e_glm.nb) #the smaller the value the better
```

```{r}
#negative binomial energy savings model for q2
counties2f_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq2)
counties2g_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq2)
counties2h_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq2)
counties2i_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq2)
counties2j_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue, data = counties_lnq2)

summary(counties2f_glm.nb) #p-value should be < 0.05 to be significant 
summary(counties2g_glm.nb)
summary(counties2h_glm.nb)
summary(counties2i_glm.nb)
summary(counties2j_glm.nb)
```

```{r}
#validate your energy savings model for q12
anova(counties2f_glm.nb, counties2g_glm.nb, counties2h_glm.nb, counties2i_glm.nb, counties2j_glm.nb, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(counties2f_glm.nb, counties2g_glm.nb, counties2h_glm.nb, counties2i_glm.nb, counties1j_glm.nb) #the smaller the value the better
BIC(counties2f_glm.nb, counties2g_glm.nb, counties2h_glm.nb, counties2i_glm.nb, counties2j_glm.nb) #the smaller the value the better
```

```{r}
#negative binomial budget model for q3
counties3a_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq3)
counties3b_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq3)
counties3c_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq3)
counties3d_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq3)
counties3e_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue, data = counties_lnq3)


summary(counties3a_glm.nb)#p-value should be < 0.05 to be significant
summary(counties3b_glm.nb)
summary(counties3c_glm.nb)
summary(counties3d_glm.nb)
summary(counties3e_glm.nb)
```

```{r}
#negative binomial energy savings model for q3
counties3f_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq3)
counties3g_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq3)
counties3h_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq3)
counties3i_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq3)
counties3j_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue, data = counties_lnq3)

summary(counties3f_glm.nb) #p-value should be < 0.05 to be significant 
summary(counties3g_glm.nb)
summary(counties3h_glm.nb)
summary(counties3i_glm.nb)
summary(counties3j_glm.nb)
```

```{r}
#negative binomial budget model for q4
counties4a_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq4)
counties4b_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq4)
counties4c_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq4)
counties4d_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue + ces_score_median, data = counties_lnq4)
counties4e_glm.nb <- glm.nb(rounded_budget ~ TotalRevenue, data = counties_lnq4)


summary(counties4a_glm.nb)#p-value should be < 0.05 to be significant
summary(counties4b_glm.nb)
summary(counties4c_glm.nb)
summary(counties4d_glm.nb)
summary(counties4e_glm.nb)
```

```{r}
#negative binomial energy savings model for q4
counties4f_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income + Population, data = counties_lnq4)
counties4g_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR + Mean.Income, data = counties_lnq4)
counties4h_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median + IRR, data = counties_lnq4)
counties4i_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue + ces_score_median, data = counties_lnq4)
counties4j_glm.nb <- glm.nb(rounded_kWh ~ TotalRevenue, data = counties_lnq4)

summary(counties4f_glm.nb) #p-value should be < 0.05 to be significant 
summary(counties4g_glm.nb)
summary(counties4h_glm.nb)
summary(counties4i_glm.nb)
summary(counties4j_glm.nb)
```

```{r}
#scatter plot matrix to check for correlation between county specific varaibles and investment/energy savings
plot.counties.lm <- data.frame(counties$Budget, counties$TotalFirstYearGrosskWh, counties$TotalRevenue, counties$Population, counties$Mean.Income, counties$IRR, counties$ces_score_median) #subset out these variables
colnames(plot.counties.lm)<-c("Budget", "TotalFirstYearGrosskWh", "Total Revenue", "Population", "Mean Income", "IRR", "ces_score_median") #change column names back to original
pairs.panels(plot.counties.lm, density = TRUE, cor=TRUE, lm=TRUE) #scatterplot
```


```{r}
#linear regressions to see if data works using regular linear regressions using the natural log of population quantiles 

ln_TotalFirstYearGrosskWh<-log(counties_lnq1$TotalLifecycleGrosskWh+1)
counties1a_lm<-lm(ln_TotalFirstYearGrosskWh~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1a_lm)
res.counties1a_lm <- counties1a_lm$residuals#fetching residuals 
qqPlot(counties1a_lm)
shapiro.test(res.counties1a_lm) #seeing if data is normal
#data is not normal and variance is not equal
summary(counties1a_lm)

counties1aa_lm<-lm(ln_TotalFirstYearGrosskWh~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1aa_lm)
res.counties1aa_lm <- counties1aa_lm$residuals#fetching residuals 
qqPlot(counties1aa_lm)
shapiro.test(res.counties1aa_lm) #seeing if data is normal


counties1b_lm<-lm(ln_TotalFirstYearGrosskWh~TotalRevenue+IRR+Mean.Income, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1b_lm)
res.counties1b_lm <- counties1b_lm$residuals #fetching residuals
shapiro.test(res.counties1b_lm)#seeing if data is normal
#data is not normal and variance is not equal
summary(counties1b_lm)

counties1c_lm<-lm(ln_TotalFirstYearGrosskWh~TotalRevenue+IRR, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1c_lm)
res.counties1c_lm <- counties1c_lm$residuals #fetching residuals
shapiro.test(res.counties1c_lm)#seeing if data is normal
#data is not normal and variance is not equal
summary(counties1c_lm)

counties1d_lm<-lm(ln_TotalFirstYearGrosskWh~TotalRevenue, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1d_lm)
res.counties1d_lm <- counties1d_lm$residuals #fetching residuals
shapiro.test(res.counties1d_lm)#seeing if data is normal
#data is not normal and variance is not equal
summary(counties1d_lm)
```

```{r}
#validate your energy savings model for q1 using linear regression
anova(counties1a_lm, counties1aa_lm) #lower p-value means it explains the variance more which is best
AIC(counties1a_lm, counties1aa_lm) #the smaller the value the better
BIC(counties1a_lm, counties1aa_lm) #the smaller the value the better
#total rev better
```

```{r}
ln2_TotalFirstYearGrosskWh<-log(counties_lnq2$TotalLifecycleGrosskWh+1)
counties2aa_lm<-lm(ln2_TotalFirstYearGrosskWh~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq2)
counties2a_lm<-lm(ln2_TotalFirstYearGrosskWh~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq2)
par(mfrow=c(2,2))
plot(counties2a_lm)
res.counties2a_lm <- counties2a_lm$residuals#fetching residuals 
qqPlot(counties2a_lm)
shapiro.test(res.counties2a_lm) #seeing if data is normal
#data is not normal and variance is not equal
summary(counties2a_lm)
```

```{r}
#validate your energy savings model for q1 using linear regression
anova(counties2a_lm, counties2aa_lm) #lower p-value means it explains the variance more which is best
AIC(counties2a_lm, counties2aa_lm) #the smaller the value the better
BIC(counties2a_lm, counties2aa_lm) #the smaller the value the better
#total rev better
```

```{r}
ln3_TotalFirstYearGrosskWh<-log(counties_lnq3$TotalLifecycleGrosskWh+1)
counties3aa_lm<-lm(ln3_TotalFirstYearGrosskWh~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq3)
counties3a_lm<-lm(ln3_TotalFirstYearGrosskWh~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq3)
par(mfrow=c(2,2))
plot(counties3a_lm)
res.counties3a_lm <- counties3a_lm$residuals#fetching residuals 
qqPlot(counties3a_lm)
shapiro.test(res.counties3a_lm) #seeing if data is normal
#data is not normal and variance is not equal
summary(counties3a_lm)
```

```{r}
#validate your energy savings model for q1 using linear regression
anova(counties3a_lm, counties3aa_lm) #lower p-value means it explains the variance more which is best
AIC(counties3a_lm, counties3aa_lm) #the smaller the value the better
BIC(counties3a_lm, counties3aa_lm) #the smaller the value the better
#total rev better
```

```{r}
ln4_TotalFirstYearGrosskWh<-log(counties_lnq4$TotalLifecycleGrosskWh+1)
counties4aa_lm<-lm(ln4_TotalFirstYearGrosskWh~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq4)
counties4a_lm<-lm(ln4_TotalFirstYearGrosskWh~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq4)
par(mfrow=c(2,2))
plot(counties4a_lm)
res.counties4a_lm <- counties4a_lm$residuals#fetching residuals 
qqPlot(counties4a_lm)
shapiro.test(res.counties4a_lm) #seeing if data is normal
#data is not normal and variance is not equal
summary(counties4a_lm)
```

```{r}
#validate your energy savings model for q1 using linear regression
anova(counties4a_lm, counties4aa_lm) #lower p-value means it explains the variance more which is best
AIC(counties4a_lm, counties4aa_lm) #the smaller the value the better
BIC(counties4a_lm, counties4aa_lm) #the smaller the value the better
#population better
```


```{r}
ln_budget<-log(counties_lnq1$Budget+1)
counties1e_lm<-lm(ln_budget~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1e_lm)
res.counties1e_lm <- counties1e_lm$residuals#fetching residuals 
qqPlot(counties1e_lm)
shapiro.test(res.counties1e_lm) #seeing if data is normal
summary(counties1e_lm)

counties1f_lm<-lm(ln_budget~TotalRevenue+IRR+Mean.Income, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1f_lm)
res.counties1f_lm <- counties1f_lm$residuals#fetching residuals 
qqPlot(counties1f_lm)
shapiro.test(res.counties1f_lm) #seeing if data is normal
summary(counties1f_lm)

counties1g_lm<-lm(ln_budget~TotalRevenue+IRR, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1g_lm)
res.counties1g_lm <- counties1g_lm$residuals#fetching residuals 
qqPlot(counties1g_lm)
shapiro.test(res.counties1g_lm) #seeing if data is normal
summary(counties1g_lm)

counties1h_lm<-lm(ln_budget~TotalRevenue, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1h_lm)
res.counties1h_lm <- counties1h_lm$residuals#fetching residuals 
qqPlot(counties1h_lm)
shapiro.test(res.counties1h_lm) #seeing if data is normal
summary(counties1h_lm)
```

```{r}
#validate your budget for q1 using linear regression
anova(counties1e_lm, counties1f_lm, counties1g_lm, counties1h_lm) #lower p-value means it explains the variance more which is best
AIC(counties1e_lm, counties1f_lm, counties1g_lm, counties1h_lm) #the smaller the value the better
BIC(counties1e_lm, counties1f_lm, counties1g_lm, counties1h_lm) #the smaller the value the better
#without ces is the best fit 
```

```{r}
counties1ff_lm<-lm(ln_budget~Population+IRR+Mean.Income, data=counties_lnq1)
par(mfrow=c(2,2))
plot(counties1ff_lm)
res.counties1ff_lm <- counties1ff_lm$residuals#fetching residuals 
qqPlot(counties1ff_lm)
shapiro.test(res.counties1ff_lm) #seeing if data is normal
summary(counties1ff_lm)
```

```{r}
#validate your budget for q1 using linear regression
anova(counties1ff_lm, counties1f_lm) #lower p-value means it explains the variance more which is best
AIC(counties1ff_lm, counties1f_lm) #the smaller the value the better
BIC(counties1ff_lm, counties1f_lm) #the smaller the value the better
#population is better fit 
```

```{r}
ln2_budget<-log(counties_lnq2$Budget+1)
counties2ee_lm<-lm(ln2_budget~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq2)
counties2e_lm<-lm(ln2_budget~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq2)
par(mfrow=c(2,2))
plot(counties2e_lm)
res.counties2e_lm <- counties2e_lm$residuals#fetching residuals 
qqPlot(counties2e_lm)
shapiro.test(res.counties2e_lm) #seeing if data is normal
summary(counties2e_lm)
#only fit that is normally distributed

counties2f_lm<-lm(ln2_budget~TotalRevenue+IRR+Mean.Income, data=counties_lnq2)
par(mfrow=c(2,2))
plot(counties2f_lm)
res.counties2f_lm <- counties2f_lm$residuals#fetching residuals 
qqPlot(counties2f_lm)
shapiro.test(res.counties2f_lm) #seeing if data is normal
summary(counties2f_lm)

counties2g_lm<-lm(ln2_budget~TotalRevenue+IRR, data=counties_lnq2)
par(mfrow=c(2,2))
plot(counties2g_lm)
res.counties2g_lm <- counties2g_lm$residuals#fetching residuals 
qqPlot(counties2g_lm)
shapiro.test(res.counties2g_lm) #seeing if data is normal
summary(counties2g_lm)

counties2h_lm<-lm(ln2_budget~TotalRevenue, data=counties_lnq2)
par(mfrow=c(2,2))
plot(counties2h_lm)
res.counties2h_lm <- counties2h_lm$residuals#fetching residuals 
qqPlot(counties2h_lm)
shapiro.test(res.counties2h_lm) #seeing if data is normal
summary(countie21h_lm)
```

```{r}
#validate your budget for q1 using linear regression
anova(counties2ee_lm, counties2e_lm) #lower p-value means it explains the variance more which is best
AIC(counties2ee_lm, counties2e_lm) #the smaller the value the better
BIC(counties2ee_lm, counties2e_lm) #the smaller the value the better
#population is better fit 
```

```{r}
ln3_budget<-log(counties_lnq3$Budget+1)
counties3ee_lm<-lm(ln3_budget~Population+IRR+Mean.Income+ces_score_median, data=counties_lnq3)
counties3e_lm<-lm(ln3_budget~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq3)
par(mfrow=c(2,2))
plot(counties3e_lm)
res.counties3e_lm <- counties3e_lm$residuals#fetching residuals 
qqPlot(counties3e_lm)
shapiro.test(res.counties3e_lm) #seeing if data is normal
summary(counties3e_lm)
#only fit that is normally distributed

counties3f_lm<-lm(ln3_budget~TotalRevenue+IRR+Mean.Income, data=counties_lnq3)
par(mfrow=c(2,2))
plot(counties3f_lm)
res.counties3f_lm <- counties3f_lm$residuals#fetching residuals 
qqPlot(counties3f_lm)
shapiro.test(res.counties3f_lm) #seeing if data is normal
summary(counties3f_lm)

counties3g_lm<-lm(ln3_budget~TotalRevenue+IRR, data=counties_lnq3)
par(mfrow=c(2,2))
plot(counties3g_lm)
res.counties3g_lm <- counties3g_lm$residuals#fetching residuals 
qqPlot(counties3g_lm)
shapiro.test(res.counties3g_lm) #seeing if data is normal
summary(counties3g_lm)

counties3h_lm<-lm(ln3_budget~TotalRevenue, data=counties_lnq3)
par(mfrow=c(2,2))
plot(counties3h_lm)
res.counties3h_lm <- counties3h_lm$residuals#fetching residuals 
qqPlot(counties3h_lm)
shapiro.test(res.counties3h_lm) #seeing if data is normal
summary(counties3h_lm)
```

```{r}
#validate your budget for q1 using linear regression
anova(counties3h_lm, counties3e_lm) #lower p-value means it explains the variance more which is best
AIC(counties3h_lm, counties3e_lm) #the smaller the value the better
BIC(counties3h_lm, counties3e_lm) #the smaller the value the better
#first regression is better 
```

```{r}
#validate your budget for q1 using linear regression
anova(counties3ee_lm, counties3e_lm) #lower p-value means it explains the variance more which is best
AIC(counties3ee_lm, counties3e_lm) #the smaller the value the better
BIC(counties3ee_lm, counties3e_lm) #the smaller the value the better
#population is better
```

```{r}
ln4_budget<-log(counties_lnq4$Budget+1)
counties4e_lm<-lm(ln4_budget~TotalRevenue+IRR+Mean.Income+ces_score_median, data=counties_lnq4)
par(mfrow=c(2,2))
plot(counties4e_lm)
res.counties4e_lm <- counties4e_lm$residuals#fetching residuals 
qqPlot(counties4e_lm)
shapiro.test(res.counties4e_lm) #seeing if data is normal
summary(counties4e_lm)

counties4f_lm<-lm(ln4_budget~TotalRevenue+IRR+Mean.Income, data=counties_lnq4)
par(mfrow=c(2,2))
plot(counties4f_lm)
res.counties4f_lm <- counties4f_lm$residuals#fetching residuals 
qqPlot(counties4f_lm)
shapiro.test(res.counties4f_lm) #seeing if data is normal
summary(counties4f_lm)

counties4g_lm<-lm(ln4_budget~TotalRevenue+IRR, data=counties_lnq4)
par(mfrow=c(2,2))
plot(counties4g_lm)
res.counties4g_lm <- counties4g_lm$residuals#fetching residuals 
qqPlot(counties4g_lm)
shapiro.test(res.counties4g_lm) #seeing if data is normal
summary(counties4g_lm)

counties4hh_lm<-lm(ln4_budget~Population, data=counties_lnq4)
counties4h_lm<-lm(ln4_budget~TotalRevenue, data=counties_lnq4)
par(mfrow=c(2,2))
plot(counties4h_lm)
res.counties4h_lm <- counties4h_lm$residuals#fetching residuals 
qqPlot(counties4h_lm)
shapiro.test(res.counties4h_lm) #seeing if data is normal
summary(counties4h_lm)
```

```{r}
#validate your budget for q1 using linear regression
anova(counties4hh_lm, counties4h_lm) #lower p-value means it explains the variance more which is best
AIC(counties4hh_lm, counties4h_lm) #the smaller the value the better
BIC(counties4hh_lm, counties4h_lm) #the smaller the value the better
#tax revenue is better
```

```{r}
#t tests on different quantiles based on population for budget
t.test(counties_g1$Budget, counties_g4$Budget)
#significantly different means so should be run as different tests

#t tests on different quantiles based on population for energy savings
t.test(counties_g1$TotalFirstYearGrosskWh, counties_g4$TotalFirstYearGrosskWh)
#significantly different means so should be run as different tests

#t tests on different quantiles based on log of population for budget
t.test(counties_lnq1$Budget, counties_lnq4$Budget)
#significantly different means so should be run as different tests

#t tests on different quantiles based on log of population for energy savings
t.test(counties_lnq1$TotalFirstYearGrosskWh, counties_lnq4$TotalFirstYearGrosskWh)
#significantly different means so should be run as different tests
```

```{r}
#create step aic to see which combination of variables is the best fit 
stepAIC(lm(ln_budget ~ Mean.Income + TotalRevenue + Population + IRR + ces_score_median + dac_proportion, data = counties))
```

```{r}
#spline model using variables recommended by step aic
spline2_model = lm(ln_budget ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + ces_score_median + dac_proportion + IRR, data = counties)
summary(spline2_model)
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline2_model)$coefficients[,1])
counties$predict_value <- predict(spline2_model, counties, type = "response")

chisq.test(counties$ln_budget, counties$predict_value)
#the predicted values for this fit are about equal in accuracy as the other fit, both are very close and for some values this one is more accurate, and for other values the other fit is more accurate
```

```{r}
#create step aic to see which combination of variables is the best fit 
counties$ln_TotalFirstYearGrosskWh<-log(counties$TotalFirstYearGrosskWh+1)
stepAIC(lm(ln_TotalFirstYearGrosskWh ~ Mean.Income + TotalRevenue + IRR + ces_score_median + dac_proportion, data = counties))
```

```{r}
#created spline split up into four different quantiles based on the log of population because that gets rid of skew and creates specific fits for each section
#spline using step aic recommendation
library(splines)
spline3_model = lm(ln_TotalFirstYearGrosskWh ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + IRR, data = counties)
summary(spline3_model)
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline3_model)$coefficients[,1])
counties$predict_value3 <- predict(spline3_model, counties, type = "response")

chisq.test(counties$ln_TotalFirstYearGrosskWh, counties$predict_value3)
#other fit predicts the values more accurately so other fit is better model to use
```

```{r}
#created spline split up into four different quantiles based on the log of population because that gets rid of skew and creates specific fits for each section
library(splines)
spline1_model = lm(ln_TotalFirstYearGrosskWh ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + TotalRevenue + ces_score_median + dac_proportion + Mean.Income + IRR, data = counties)
summary(spline1_model)
#looking r-squared value, this is better fit
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline1_model)$coefficients[,1])
counties$predict_value2 <- predict(spline1_model, counties, type = "response")

chisq.test(counties$ln_TotalFirstYearGrosskWh, counties$predict_value2)
#this fit has better predicted values based on chi-squared so this is a better fit
```

```{r}
#created spline split up into four different quantiles based on the log of population because that gets rid of skew and creates specific fits for each section
library(splines)
counties$ln_budget<-log(counties$Budget+1)
spline_model = lm(ln_budget ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + TotalRevenue + ces_score_median + Mean.Income + IRR + dac_proportion, data = counties)
summary(spline_model)
plot(spline_model)
#estimates make sense except for total revenue 
#this spline is better fit when looking at r-squared value
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline_model)$coefficients[,1])
counties$predict_value1 <- predict(spline_model, counties, type = "response")

chisq.test(counties$ln_budget, counties$predict_value1)
##the predicted values for this fit are about equal in accuracy as the other fit, both are very close and for some values this one is more accurate, and for other values the other fit is more accurate
```

```{r}
#put in demographic variables and see how that fits in to step aic
stepAIC(lm(ln_budget ~ Mean.Income + TotalRevenue + IRR + ces_score_median + dac_proportion + perc_wa_avg + perc_ba_avg + perc_ia_avg + perc_aa_avg + perc_na_avg, data = counties))
```

```{r}
#put in demographic variables and see how that fits in to spline (spline using step aic recommendation)
spline4_model = lm(ln_budget ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + IRR + perc_ia_avg, data = counties)
summary(spline4_model)
#no variables seem significant and estimates are interesting
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline4_model)$coefficients[,1])
counties$predict_value4 <- predict(spline4_model, counties, type = "response")

chisq.test(counties$ln_budget, counties$predict_value4)
#the fit with all the demographic varirables predicts log of budget better
```

```{r}
#put in demographic variables and see how that fits in to spline
spline5_model = lm(ln_budget ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + TotalRevenue + ces_score_median + Mean.Income + IRR + dac_proportion + perc_wa_avg + perc_ba_avg + perc_ia_avg + perc_aa_avg + perc_na_avg, data = counties)
summary(spline5_model)
#no variables seem significant and estimates are interesting
#this is better fit when looking at r-squared value
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline5_model)$coefficients[,1])
counties$predict_value5 <- predict(spline5_model, counties, type = "response")

chisq.test(counties$ln_budget, counties$predict_value5)
#spline 5 predicts the values better than spline 4, which means the model with all variables predicts the values better than the fit the step aic predicts, but the models without the demographics are better than the fit with the demographics
```

```{r}
#put in demographic variables and see how that fits in to step aic
stepAIC(lm(ln_TotalFirstYearGrosskWh ~ Mean.Income + TotalRevenue + IRR + ces_score_median + dac_proportion + perc_wa_avg + perc_ba_avg + perc_ia_avg + perc_aa_avg + perc_na_avg, data = counties))
#still showing highest aic for the fit with the most amount of variables but idk if thats too many??
```

```{r}
#spline using all of the variables 
spline6_model = lm(ln_TotalFirstYearGrosskWh ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + TotalRevenue + ces_score_median + Mean.Income + IRR + dac_proportion + perc_wa_avg + perc_ba_avg + perc_ia_avg + perc_aa_avg + perc_na_avg, data = counties)
summary(spline6_model)
#this is better fit when looking at r-squared value
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline6_model)$coefficients[,1])
counties$predict_value6 <- predict(spline6_model, counties, type = "response")

chisq.test(counties$ln_TotalFirstYearGrosskWh, counties$predict_value6)
#this a better predictor but the regression without the demographic variables is still better
```

```{r}
#spline using the variables that step aic predicted
spline7_model = lm(ln_TotalFirstYearGrosskWh ~ splines::bs(ln_Population, knots = c(10.768725,12.125893, 13.439743)) + IRR + perc_ia_avg, data = counties)
summary(spline7_model)
```

```{r}
#chi-squared to see if it predicts value
exp(summary(spline7_model)$coefficients[,1])
counties$predict_value7 <- predict(spline7_model, counties, type = "response")

chisq.test(counties$ln_TotalFirstYearGrosskWh, counties$predict_value7)
#does not predict well
```

Overall for both budget and energy savings the splines with all the variables are better than the splines that use the step AIC predicted variables but when comparing the splines with the demographic variables to the splines without the demographic variables, the splines without the demographic are better fits
In conclusion the two best splines are budget with all economic variables but not demographic variables and energy savings with all economic variables but not demographic variables

```{r}
#split up budget in to quantiles and then create a group of the smallest budgets and largest budgets
quantile(counties$Budget)
bottomq_budget = subset(counties, Budget <= 168429.5)
topq_budget = subset(counties, Budget > 3441408.1)

mean(bottomq_budget$perc_wa_avg) #86.4427%
mean(topq_budget$perc_wa_avg) #69.49446%
mean(bottomq_budget$perc_ba_avg) #1.91%
mean(topq_budget$perc_ba_avg) #6.03%%
mean(bottomq_budget$perc_aa_avg) #1.71%
mean(topq_budget$perc_aa_avg) #17.88%
mean(bottomq_budget$perc_ia_avg) #5.90%
mean(topq_budget$perc_ia_avg) #1.60%
mean(bottomq_budget$perc_na_avg) #0.277%
mean(topq_budget$perc_na_avg) #0.594%

#split up energy savings in to quantiles and then create a group of the smallest energy savings and largest energy savings
quantile(counties$TotalFirstYearGrosskWh)
bottomq_energy = subset(counties, Budget <= 152553.2)
topq_energy = subset(counties, Budget > 6333300.1)

mean(bottomq_energy$perc_wa_avg)#86.16%
mean(topq_energy$perc_wa_avg) #63.53%
mean(bottomq_energy$perc_ba_avg) #1.89%
mean(topq_energy$perc_ba_avg) #7.88%%
mean(bottomq_energy$perc_aa_avg) #1.73%
mean(topq_energy$perc_aa_avg) #22.10%
mean(bottomq_energy$perc_ia_avg) #6.16%
mean(topq_energy$perc_ia_avg)#1.38%
mean(bottomq_energy$perc_na_avg) #0.277%
mean(topq_energy$perc_na_avg) #0.589%
```

```{r, EE Programs at the City Level}
#read in data for City EE programs 
cities <- read.csv("cities_2.csv")
```

```{r, city—check}
#scatter plot matrix to check for correlation between city population and investment/energy savings
plot.cities <- data.frame(cities$SiteCity, cities$TotalFirstYearGrosskWh, cities$Budget, cities$total_population) #subset out these variables
colnames(plot.cities)<-c("SiteCity", "TotalFirstYearGrosskWh", "Budget", "total_population") #change column names back to original
pairs.panels(plot.cities, density = TRUE, cor=TRUE, lm=TRUE) #scatterplot
```

```{r, city}
#log-transform the population to account for the skew
cities$ln_population <- log(cities$total_population)
#visualize the normal distribution
hist(cities$ln_population)
```

```{r, city}
#split into groups based on quantiles
quantile(cities$ln_population)

#group data by ln_population
cities_lnq1 <- subset(cities, ln_population < 9.076352)
cities_lnq2 <- subset(cities, ln_population >= 9.076352 & ln_population < 10.124950)
cities_lnq3 <- subset(cities, ln_population >= 10.124950 & ln_population < 11.129408)
cities_lnq4 <- subset(cities, ln_population > 11.129408)
```

```{r, city}
#check the distribution of the predictor variable of interest (Budget)
hist(cities_lnq1$Budget)
hist(cities_lnq2$Budget)
hist(cities_lnq3$Budget)
hist(cities_lnq4$Budget)
```
```{r, city}
#check the distribution of the predictor variable of interest (Energy Savings)
hist(cities_lnq1$TotalFirstYearGrosskWh)
hist(cities_lnq2$TotalFirstYearGrosskWh)
hist(cities_lnq3$TotalFirstYearGrosskWh)
hist(cities_lnq4$TotalFirstYearGrosskWh)
```

```{r, city—check}
#round y because GLM works best with integers 
cities_lnq1$rounded_budget <- round(cities_lnq1$Budget, 0)
cities_lnq2$rounded_budget <- round(cities_lnq2$Budget, 0)
cities_lnq3$rounded_budget <- round(cities_lnq3$Budget, 0)
cities_lnq4$rounded_budget <- round(cities_lnq4$Budget, 0)

cities_lnq1$rounded_kWh <- round(cities_lnq1$TotalFirstYearGrosskWh, 0)
cities_lnq2$rounded_kWh <- round(cities_lnq2$TotalFirstYearGrosskWh, 0)
cities_lnq3$rounded_kWh <- round(cities_lnq3$TotalFirstYearGrosskWh, 0)
cities_lnq4$rounded_kWh <- round(cities_lnq4$TotalFirstYearGrosskWh, 0)
```

```{r, city—check}
#check which distribution would be best for the budget of the SMALLEST population group
cities1_pois <- fitdist(cities_lnq1$rounded_budget, "pois") #CHECK
cities1_nbin <- fitdist(cities_lnq1$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(cities1_pois, cities1_nbin))
qqcomp(list(cities1_pois, cities1_nbin))

summary(cities1_pois)
summary(cities1_nbin)
```

````{r, city}
#poisson budget regression for q1
cities_1a.glm <- glm(rounded_budget ~ Total.Tax.Revenue, data = cities_lnq1, family = "poisson")
cities_1b.glm <- glm(rounded_budget ~ Total.Tax.Revenue + ruca_average, data = cities_lnq1, family = "poisson")
cities_1c.glm <- glm(rounded_budget ~ Total.Tax.Revenue + ruca_average + ces_score_median, data = cities_lnq1, family = "poisson")
cities_1d.glm <- glm(rounded_budget ~ Total.Tax.Revenue +  ruca_average + ces_score_median + total_population, data = cities_lnq1, family = "poisson")
cities_1e.glm <- glm(rounded_budget ~ Total.Tax.Revenue + ruca_average + ces_score_median + total_population + median_household_income_usd, data = cities_lnq1, family = "poisson")

summary(cities_1a.glm) #p-value should be < 0.05 to be significant 
summary(cities_1b.glm)
summary(cities_1c.glm)
summary(cities_1d.glm)
summary(cities_1e.glm)
```

````{r, city}
#poisson energy savings regression for q1
cities_1f.glm <- glm(rounded_kWh ~ Total.Tax.Revenue, data = cities_lnq1, family = "poisson")
cities_1g.glm <- glm(rounded_kWh ~ Total.Tax.Revenue + ruca_average, data = cities_lnq1, family = "poisson")
cities_1h.glm <- glm(rounded_kWh ~ Total.Tax.Revenue + ruca_average + ces_score_median, data = cities_lnq1, family = "poisson")
cities_1i.glm <- glm(rounded_kWh ~ Total.Tax.Revenue +  ruca_average + ces_score_median + total_population, data = cities_lnq1, family = "poisson")
cities_1j.glm <- glm(rounded_kWh ~ Total.Tax.Revenue + ruca_average + ces_score_median + total_population + median_household_income_usd, data = cities_lnq1, family = "poisson")

summary(cities_1f.glm) #p-value should be < 0.05 to be significant 
summary(cities_1g.glm)
summary(cities_1h.glm)
summary(cities_1i.glm)
summary(cities_1j.glm)
```

```{r, city}
#regression on ungrouped city programs w/ total_pop; note budget and kWh are not rounded for this
citiesa.glm <- glm(TotalFirstYearGrosskWh ~ Total.Tax.Revenue + ruca_average + ces_score_median + total_population + median_household_income_usd, data = cities, family = "poisson")
citiesb.glm <- glm(Budget ~ Total.Tax.Revenue + ruca_average + ces_score_median + total_population + median_household_income_usd, data = cities, family = "poisson")

summary(citiesa.glm)
summary(citiesb.glm)
```

```{r, city}
#regression on ungrouped city programs w/ ln_pop; note budget and kWh are not rounded for this
citiesc.glm <- glm(TotalFirstYearGrosskWh ~ Total.Tax.Revenue + ruca_average + ces_score_median + ln_population + median_household_income_usd, data = cities, family = "poisson")
citiesd.glm <- glm(Budget ~ Total.Tax.Revenue + ruca_average + ces_score_median + ln_population + median_household_income_usd, data = cities, family = "poisson")

summary(citiesc.glm)
summary(citiesd.glm)
```

```{r, K12 Programs}
#read in data for K-12 EE programs 
K12 <- read.csv("k12_counties_2.csv")
```

```{r, K12}
#scatter plot matrix to check for correlation between school enrollment and investment/energy savings
plot.K12 <- data.frame(K12$county_name, K12$TotalFirstYearGrosskWh, K12$Budget, K12$total_lcff_entitlement, K12$enrollment, K12$perc_title1_status, K12$perc_eligible_frpm, K12$perc_eligible_free, K12$mean_household_income_usd, counties$IRR, K12$dac_proportion, K12$ces_score_median, K12$ces_percentile_median, K12$perc_obf_budget, K12$perc_resource_budget) #subset out these variables
colnames(plot.K12)<-c("county_name", "TotalFirstYearGrosskWh", "Budget", "total_lcff_entitlement", "enrollment","perc_title1_status", "perc_eligible_frpm", "perc_eligible_free", "mean_household_income_usd", "IRR","dac_proportion", "ces_score_median", "ces_percentile_median", "perc_obf_budget","perc_resource_budget") #change column names back to original
pairs.panels(plot.K12, density = TRUE, cor=TRUE, lm=TRUE) #scatterplot
```

```{r, K12}
#log-transform the enrollment to account for the skew
K12$ln_enrollment <- log(K12$enrollment)
#visualize the normal distribution
hist(K12$ln_enrollment)
```

```{r, K12}
#split into groups
quantile(K12$ln_enrollment)

#group data by ln_population
K12_lnq1 <- subset(K12, ln_enrollment < 8.707481)
K12_lnq2 <- subset(K12, ln_enrollment >= 8.707481 & ln_enrollment < 10.336310)
K12_lnq3 <- subset(K12, ln_enrollment >= 10.336310 & ln_enrollment < 11.532670)
K12_lnq4 <- subset(K12, ln_enrollment > 11.532670)
```

```{r, K12}
#check the distribution of the predictor variable of interest (Budget)
hist(K12_lnq1$Budget)
hist(K12_lnq2$Budget)
hist(K12_lnq3$Budget)
hist(K12_lnq4$Budget)
```
```{r, K12}
#check the distribution of the predictor variable of interest (Energy Savings)
hist(K12_lnq1$TotalFirstYearGrosskWh)
hist(K12_lnq2$TotalFirstYearGrosskWh)
hist(K12_lnq3$TotalFirstYearGrosskWh)
hist(K12_lnq4$TotalFirstYearGrosskWh)
```

```{r, K12}
#check the distribution of the predictor variable of interest (Budget)
hist(K12$Budget)
```
```{r, K12}
#check the distribution of the predictor variable of interest (Energy Savings)
hist(K12$TotalFirstYearGrosskWh)
```

```{r, K12—check}
#round y because GLM works best with integers 
K12_lnq1$rounded_budget <- round(K12_lnq1$Budget, 0)
K12_lnq2$rounded_budget <- round(K12_lnq2$Budget, 0)
K12_lnq3$rounded_budget <- round(K12_lnq3$Budget, 0)
K12_lnq4$rounded_budget <- round(K12_lnq4$Budget, 0)

K12_lnq1$rounded_kWh <- round(K12_lnq1$TotalFirstYearGrosskWh, 0)
K12_lnq2$rounded_kWh <- round(K12_lnq2$TotalFirstYearGrosskWh, 0)
K12_lnq3$rounded_kWh <- round(K12_lnq3$TotalFirstYearGrosskWh, 0)
K12_lnq4$rounded_kWh <- round(K12_lnq4$TotalFirstYearGrosskWh, 0)

K12$rounded_budget <- round(K12$Budget, 0)
K12$rounded_kWh <- round(K12$TotalFirstYearGrosskWh, 0)
```

```{r, K12—check}
#check which distribution would be best for the budget of the SMALLEST population group
K121_pois <- fitdist(K12_lnq1$rounded_budget, "pois") #CHECK
K121_nbin <- fitdist(K12_lnq1$rounded_budget, "nbinom") #CHECK

par(mfrow=c(1,2))
denscomp(list(K121_pois, K121_nbin))
qqcomp(list(K121_pois, K121_nbin))

summary(K121_pois)
summary(K121_nbin)
```

````{r, K12}
#poisson budget regression for entire population
K12_1.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd, data = K12, family = "poisson")
K12_2.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd +  perc_title1_status, data = K12, family = "poisson")
K12_3.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + perc_eligible_free, data = K12, family = "poisson")
K12_4.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + perc_title1_status + perc_eligible_frpm, data = K12, family = "poisson")
K12_5.glm <- glm(rounded_budget ~ IRR + ces_score_median + perc_title1_status, data = K12, family = "poisson")

summary(K12_1.glm) #p-value should be < 0.05 to be significant 
summary(K12_2.glm)
summary(K12_3.glm)
summary(K12_4.glm)
summary(K12_5.glm)
```

````{r, K12}
#poisson budget regression for q1
K12_1a.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd, data = K12_lnq1, family = "poisson")
K12_1b.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd +  perc_title1_status, data = K12_lnq1, family = "poisson")
K12_1c.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + perc_eligible_free, data = K12_lnq1, family = "poisson")
K12_1d.glm <- glm(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + perc_eligible_free + perc_title1_status + perc_eligible_frpm, data = K12_lnq1, family = "poisson")
K12_1e.glm <- glm(rounded_budget ~ IRR + ces_score_median + perc_title1_status, data = K12_lnq1, family = "poisson")

summary(K12_1a.glm) #p-value should be < 0.05 to be significant 
summary(K12_1b.glm)
summary(K12_1c.glm)
summary(K12_1d.glm)
summary(K12_1e.glm)
```

````{r, K12}
#poisson energy savings regression for q1
K12_1f.glm <- glm(rounded_kWh ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment, data = K12_lnq1, family = "poisson")
K12_1g.glm <- glm(rounded_kWh ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + no_title1_status, data = K12_lnq1, family = "poisson")
K12_1h.glm <- glm(rounded_kWh ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + free_meal_count, data = K12_lnq1, family = "poisson")
K12_1i.glm <- glm(rounded_kWh ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment + free_meal_count + no_title1_status + frpm_count, data = K12_lnq1, family = "poisson")
K12_1j.glm <- glm(rounded_kWh ~ IRR + ces_score_median + no_title1_status, data = K12_lnq1, family = "poisson")

summary(K12_1f.glm) #p-value should be < 0.05 to be significant 
summary(K12_1g.glm)
summary(K12_1h.glm)
summary(K12_1i.glm)
summary(K12_1j.glm)
```

```{r, K12}
#validate your budget model
anova(K12_1a.glm, K12_1b.glm, K12_1c.glm, K12_1d.glm, K12_1e.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(K12_1a.glm, K12_1b.glm, K12_1c.glm, K12_1d.glm, K12_1e.glm) #the smaller the value the better
BIC(K12_1a.glm, K12_1b.glm, K12_1c.glm, K12_1d.glm, K12_1e.glm) #the smaller the value the better
```
```{r, K12}
#validate your energy savings model
anova(K12_1f.glm, K12_1g.glm, K12_1h.glm, K12_1i.glm, K12_1j.glm, test="Chisq") #lower p-value means it explains the variance more which is best
AIC(K12_1f.glm, K12_1g.glm, K12_1h.glm, K12_1i.glm, K12_1j.glm) #the smaller the value the better
BIC(K12_1f.glm, K12_1g.glm, K12_1h.glm, K12_1i.glm, K12_1j.glm) #the smaller the value the better
```

```{r, K-12—check}
#negative binomial budget model
K121a_glm.nb <- glm.nb(rounded_budget ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment, data = K12_lnq1)
summary(K121a_glm.nb)
```
```{r, K-12—check}
#negative binomial energy savings model
K121b_glm.nb <- glm.nb(rounded_kWh ~ total_lcff_entitlement + ces_score_median + IRR + median_household_income_usd + enrollment, data = K12_lnq1)
summary(K121b_glm.nb)
```

